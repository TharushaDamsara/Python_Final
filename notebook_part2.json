{
    "cells": [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "<a id='phase2'></a>\n",
                "# Phase 2: Data Enrichment via Web Scraping\n",
                "\n",
                "In this phase, we enhance diagnosis data with medical meaning by:\n",
                "- Identifying top 20 most frequent ICD-9 codes\n",
                "- Building ethical web scraping script\n",
                "- Scraping ICD-9 descriptions from public sources\n",
                "- Adding Primary_Diagnosis_Desc column"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2.1 Analyze Primary Diagnosis Codes"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Analyze diag_1 (primary diagnosis)\n",
                "print(\"=\" * 70)\n",
                "print(\"PRIMARY DIAGNOSIS (diag_1) ANALYSIS\")\n",
                "print(\"=\" * 70)\n",
                "\n",
                "# Get value counts\n",
                "diag1_counts = df['diag_1'].value_counts()\n",
                "print(f\"\\nTotal unique ICD-9 codes in diag_1: {len(diag1_counts):,}\")\n",
                "print(f\"Missing values: {df['diag_1'].isna().sum():,}\")\n",
                "\n",
                "# Top 20 most frequent codes\n",
                "top_20_codes = diag1_counts.head(20)\n",
                "print(\"\\nTop 20 Most Frequent ICD-9 Codes:\")\n",
                "print(top_20_codes)\n",
                "\n",
                "# Calculate coverage\n",
                "coverage = (top_20_codes.sum() / len(df)) * 100\n",
                "print(f\"\\nTop 20 codes cover {coverage:.2f}% of all patients\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Visualize top 20 codes\n",
                "plt.figure(figsize=(12, 6))\n",
                "top_20_codes.plot(kind='bar', color='steelblue', alpha=0.8)\n",
                "plt.title('Top 20 Most Frequent Primary Diagnosis Codes (ICD-9)', fontsize=14, fontweight='bold')\n",
                "plt.xlabel('ICD-9 Code', fontsize=12)\n",
                "plt.ylabel('Frequency', fontsize=12)\n",
                "plt.xticks(rotation=45, ha='right')\n",
                "plt.tight_layout()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2.2 Web Scraping ICD-9 Descriptions\n",
                "\n",
                "**Ethical Scraping Practices:**\n",
                "- Using public medical coding reference (ICD9Data.com)\n",
                "- Implementing delays between requests (time.sleep)\n",
                "- Setting appropriate User-Agent headers\n",
                "- Handling errors gracefully\n",
                "- Respecting rate limits"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "import requests\n",
                "from bs4 import BeautifulSoup\n",
                "import time\n",
                "\n",
                "# Get list of top 20 codes\n",
                "top_20_list = top_20_codes.index.tolist()\n",
                "\n",
                "print(\"Starting web scraping for top 20 ICD-9 codes...\")\n",
                "print(\"This may take a few moments due to ethical delay between requests.\\n\")\n",
                "\n",
                "# Dictionary to store code descriptions\n",
                "icd9_descriptions = {}\n",
                "\n",
                "# Scrape descriptions\n",
                "for i, code in enumerate(top_20_list, 1):\n",
                "    print(f\"[{i}/20] Scraping ICD-9 code: {code}...\", end=' ')\n",
                "    \n",
                "    description = scrape_icd9_description(code, delay=0.5)\n",
                "    icd9_descriptions[str(code)] = description\n",
                "    \n",
                "    print(f\"âœ“ {description}\")\n",
                "\n",
                "print(\"\\nâœ“ Web scraping complete!\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Display scraped descriptions\n",
                "print(\"=\" * 70)\n",
                "print(\"SCRAPED ICD-9 DESCRIPTIONS\")\n",
                "print(\"=\" * 70)\n",
                "\n",
                "desc_df = pd.DataFrame.from_dict(icd9_descriptions, orient='index', columns=['Description'])\n",
                "desc_df.index.name = 'ICD-9 Code'\n",
                "desc_df['Frequency'] = desc_df.index.map(lambda x: diag1_counts.get(x, 0))\n",
                "print(desc_df)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2.3 Add Primary_Diagnosis_Desc Column"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create mapping function\n",
                "def map_diagnosis_description(code):\n",
                "    \"\"\"Map ICD-9 code to description, label non-top-20 as 'Other'\"\"\"\n",
                "    if pd.isna(code):\n",
                "        return 'Missing'\n",
                "    code_str = str(code)\n",
                "    return icd9_descriptions.get(code_str, 'Other')\n",
                "\n",
                "# Apply mapping\n",
                "df['Primary_Diagnosis_Desc'] = df['diag_1'].apply(map_diagnosis_description)\n",
                "\n",
                "print(\"âœ“ Added 'Primary_Diagnosis_Desc' column\")\n",
                "print(f\"\\nValue distribution:\")\n",
                "print(df['Primary_Diagnosis_Desc'].value_counts())"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2.4 Phase 2 Summary"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "print(\"=\" * 70)\n",
                "print(\"PHASE 2: DATA ENRICHMENT COMPLETE\")\n",
                "print(\"=\" * 70)\n",
                "print(\"\\nEnrichment Actions Performed:\")\n",
                "print(f\"  1. âœ“ Identified top 20 ICD-9 codes (covering {coverage:.2f}% of patients)\")\n",
                "print(f\"  2. âœ“ Scraped {len(icd9_descriptions)} ICD-9 descriptions from ICD9Data.com\")\n",
                "print(\"  3. âœ“ Implemented ethical scraping practices (delays, headers, error handling)\")\n",
                "print(\"  4. âœ“ Added 'Primary_Diagnosis_Desc' column\")\n",
                "print(\"  5. âœ“ Labeled non-top-20 diagnoses as 'Other'\")\n",
                "print(\"=\" * 70)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "<a id='phase3'></a>\n",
                "# Phase 3: Exploratory Data Analysis (EDA)\n",
                "\n",
                "In this phase, we discover patterns and insights driving readmissions:\n",
                "- Analyze class imbalance\n",
                "- Visualize demographic patterns\n",
                "- Compare medication usage\n",
                "- Analyze operational metrics\n",
                "- Create correlation analyses"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 3.1 Class Imbalance Analysis"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Analyze readmission distribution\n",
                "print(\"=\" * 70)\n",
                "print(\"READMISSION CLASS DISTRIBUTION\")\n",
                "print(\"=\" * 70)\n",
                "\n",
                "readmit_counts = df['readmitted'].value_counts()\n",
                "readmit_pct = df['readmitted'].value_counts(normalize=True) * 100\n",
                "\n",
                "readmit_summary = pd.DataFrame({\n",
                "    'Count': readmit_counts,\n",
                "    'Percentage': readmit_pct.round(2)\n",
                "})\n",
                "\n",
                "print(readmit_summary)\n",
                "\n",
                "# Calculate 30-day readmission rate\n",
                "readmit_30_rate = (df['readmitted'] == '<30').sum() / len(df) * 100\n",
                "print(f\"\\n30-Day Readmission Rate: {readmit_30_rate:.2f}%\")\n",
                "print(f\"This is {'ABOVE' if readmit_30_rate > 15 else 'BELOW'} the typical 15-20% benchmark\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Visualize class distribution\n",
                "fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n",
                "\n",
                "# Count plot\n",
                "readmit_counts.plot(kind='bar', ax=axes[0], color=['#2ecc71', '#e74c3c', '#3498db'], alpha=0.8)\n",
                "axes[0].set_title('Readmission Status Distribution', fontsize=14, fontweight='bold')\n",
                "axes[0].set_xlabel('Readmission Status', fontsize=12)\n",
                "axes[0].set_ylabel('Count', fontsize=12)\n",
                "axes[0].set_xticklabels(axes[0].get_xticklabels(), rotation=0)\n",
                "\n",
                "# Pie chart\n",
                "axes[1].pie(readmit_counts, labels=readmit_counts.index, autopct='%1.1f%%',\n",
                "            colors=['#2ecc71', '#e74c3c', '#3498db'], startangle=90)\n",
                "axes[1].set_title('Readmission Status Proportion', fontsize=14, fontweight='bold')\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()\n",
                "\n",
                "print(\"\\nðŸ“Š Interpretation: The dataset shows class imbalance, with <30 day readmissions\")\n",
                "print(\"being the minority class. This is clinically realistic and will inform our\")\n",
                "print(\"risk stratification approach.\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 3.2 Demographic Analysis"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 3.2.1 Age Analysis"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Readmission by age group\n",
                "fig, axes = plt.subplots(1, 2, figsize=(16, 6))\n",
                "\n",
                "# Count plot\n",
                "sns.countplot(data=df, x='age', hue='readmitted', ax=axes[0], palette='Set2')\n",
                "axes[0].set_title('Readmission Status by Age Group', fontsize=14, fontweight='bold')\n",
                "axes[0].set_xlabel('Age Group', fontsize=12)\n",
                "axes[0].set_ylabel('Count', fontsize=12)\n",
                "axes[0].tick_params(axis='x', rotation=45)\n",
                "axes[0].legend(title='Readmitted', loc='upper left')\n",
                "\n",
                "# Readmission rate by age\n",
                "age_readmit_rate = df.groupby('age')['readmitted'].apply(\n",
                "    lambda x: (x == '<30').sum() / len(x) * 100\n",
                ").sort_index()\n",
                "\n",
                "age_readmit_rate.plot(kind='bar', ax=axes[1], color='coral', alpha=0.8)\n",
                "axes[1].set_title('30-Day Readmission Rate by Age Group', fontsize=14, fontweight='bold')\n",
                "axes[1].set_xlabel('Age Group', fontsize=12)\n",
                "axes[1].set_ylabel('Readmission Rate (%)', fontsize=12)\n",
                "axes[1].axhline(y=readmit_30_rate, color='red', linestyle='--', label=f'Overall: {readmit_30_rate:.2f}%')\n",
                "axes[1].tick_params(axis='x', rotation=45)\n",
                "axes[1].legend()\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()\n",
                "\n",
                "print(\"\\nðŸ“Š Clinical Interpretation:\")\n",
                "print(f\"Highest readmission rate: {age_readmit_rate.idxmax()} ({age_readmit_rate.max():.2f}%)\")\n",
                "print(f\"Lowest readmission rate: {age_readmit_rate.idxmin()} ({age_readmit_rate.min():.2f}%)\")\n",
                "print(\"Age appears to be a significant factor in readmission risk.\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 3.2.2 Gender Analysis"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Readmission by gender\n",
                "fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n",
                "\n",
                "# Count plot\n",
                "sns.countplot(data=df, x='gender', hue='readmitted', ax=axes[0], palette='Set2')\n",
                "axes[0].set_title('Readmission Status by Gender', fontsize=14, fontweight='bold')\n",
                "axes[0].set_xlabel('Gender', fontsize=12)\n",
                "axes[0].set_ylabel('Count', fontsize=12)\n",
                "axes[0].legend(title='Readmitted')\n",
                "\n",
                "# Readmission rate by gender\n",
                "gender_readmit_rate = df.groupby('gender')['readmitted'].apply(\n",
                "    lambda x: (x == '<30').sum() / len(x) * 100\n",
                ")\n",
                "\n",
                "gender_readmit_rate.plot(kind='bar', ax=axes[1], color='skyblue', alpha=0.8)\n",
                "axes[1].set_title('30-Day Readmission Rate by Gender', fontsize=14, fontweight='bold')\n",
                "axes[1].set_xlabel('Gender', fontsize=12)\n",
                "axes[1].set_ylabel('Readmission Rate (%)', fontsize=12)\n",
                "axes[1].axhline(y=readmit_30_rate, color='red', linestyle='--', label=f'Overall: {readmit_30_rate:.2f}%')\n",
                "axes[1].set_xticklabels(axes[1].get_xticklabels(), rotation=0)\n",
                "axes[1].legend()\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()\n",
                "\n",
                "print(\"\\nðŸ“Š Clinical Interpretation:\")\n",
                "print(gender_readmit_rate)\n",
                "print(f\"Gender difference in readmission: {abs(gender_readmit_rate.iloc[0] - gender_readmit_rate.iloc[1]):.2f}%\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 3.2.3 Race Analysis"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Readmission by race\n",
                "fig, axes = plt.subplots(1, 2, figsize=(16, 6))\n",
                "\n",
                "# Count plot\n",
                "race_order = df['race'].value_counts().index\n",
                "sns.countplot(data=df, x='race', hue='readmitted', ax=axes[0], palette='Set2', order=race_order)\n",
                "axes[0].set_title('Readmission Status by Race', fontsize=14, fontweight='bold')\n",
                "axes[0].set_xlabel('Race', fontsize=12)\n",
                "axes[0].set_ylabel('Count', fontsize=12)\n",
                "axes[0].tick_params(axis='x', rotation=45)\n",
                "axes[0].legend(title='Readmitted', loc='upper right')\n",
                "\n",
                "# Readmission rate by race\n",
                "race_readmit_rate = df.groupby('race')['readmitted'].apply(\n",
                "    lambda x: (x == '<30').sum() / len(x) * 100\n",
                ").sort_values(ascending=False)\n",
                "\n",
                "race_readmit_rate.plot(kind='bar', ax=axes[1], color='lightcoral', alpha=0.8)\n",
                "axes[1].set_title('30-Day Readmission Rate by Race', fontsize=14, fontweight='bold')\n",
                "axes[1].set_xlabel('Race', fontsize=12)\n",
                "axes[1].set_ylabel('Readmission Rate (%)', fontsize=12)\n",
                "axes[1].axhline(y=readmit_30_rate, color='red', linestyle='--', label=f'Overall: {readmit_30_rate:.2f}%')\n",
                "axes[1].tick_params(axis='x', rotation=45)\n",
                "axes[1].legend()\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()\n",
                "\n",
                "print(\"\\nðŸ“Š Clinical Interpretation:\")\n",
                "print(race_readmit_rate)\n",
                "print(\"\\nRacial disparities in readmission rates may reflect social determinants\")\n",
                "print(\"of health, access to care, and systemic healthcare inequities.\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 3.3 Medication Usage Analysis"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create medication categories\n",
                "def categorize_medication(row):\n",
                "    \"\"\"Categorize patients by medication usage\"\"\"\n",
                "    insulin = row.get('insulin', 'No')\n",
                "    diabetesMed = row.get('diabetesMed', 'No')\n",
                "    \n",
                "    if insulin in ['Down', 'Steady', 'Up']:\n",
                "        return 'Insulin User'\n",
                "    elif diabetesMed == 'Yes':\n",
                "        return 'Oral Medication'\n",
                "    else:\n",
                "        return 'No Medication'\n",
                "\n",
                "df['Medication_Category'] = df.apply(categorize_medication, axis=1)\n",
                "\n",
                "print(\"Medication Category Distribution:\")\n",
                "print(df['Medication_Category'].value_counts())"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Analyze readmission by medication category\n",
                "fig, axes = plt.subplots(1, 2, figsize=(16, 6))\n",
                "\n",
                "# Count plot\n",
                "med_order = df['Medication_Category'].value_counts().index\n",
                "sns.countplot(data=df, x='Medication_Category', hue='readmitted', ax=axes[0], \n",
                "              palette='Set2', order=med_order)\n",
                "axes[0].set_title('Readmission Status by Medication Category', fontsize=14, fontweight='bold')\n",
                "axes[0].set_xlabel('Medication Category', fontsize=12)\n",
                "axes[0].set_ylabel('Count', fontsize=12)\n",
                "axes[0].tick_params(axis='x', rotation=15)\n",
                "axes[0].legend(title='Readmitted')\n",
                "\n",
                "# Readmission rate\n",
                "med_readmit_rate = df.groupby('Medication_Category')['readmitted'].apply(\n",
                "    lambda x: (x == '<30').sum() / len(x) * 100\n",
                ").sort_values(ascending=False)\n",
                "\n",
                "med_readmit_rate.plot(kind='bar', ax=axes[1], color='mediumseagreen', alpha=0.8)\n",
                "axes[1].set_title('30-Day Readmission Rate by Medication Category', fontsize=14, fontweight='bold')\n",
                "axes[1].set_xlabel('Medication Category', fontsize=12)\n",
                "axes[1].set_ylabel('Readmission Rate (%)', fontsize=12)\n",
                "axes[1].axhline(y=readmit_30_rate, color='red', linestyle='--', label=f'Overall: {readmit_30_rate:.2f}%')\n",
                "axes[1].tick_params(axis='x', rotation=15)\n",
                "axes[1].legend()\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()\n",
                "\n",
                "print(\"\\nðŸ“Š Clinical Interpretation:\")\n",
                "print(med_readmit_rate)\n",
                "print(\"\\nMedication management appears to influence readmission risk.\")\n",
                "print(\"Insulin users may represent more severe diabetes cases.\")"
            ]
        }
    ],
    "metadata": {
        "kernelspec": {
            "display_name": "Python 3",
            "language": "python",
            "name": "python3"
        },
        "language_info": {
            "name": "python",
            "version": "3.8.0"
        }
    },
    "nbformat": 4,
    "nbformat_minor": 4
}